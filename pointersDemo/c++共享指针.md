# 什么时候使用共享指针？

1. 同样一份数据，被多个对象共同使用，且不存在数据和对象
相互之间引用的情况
2. 多个对象访问同一个数据时，即使修改数据，也不会影响其他使用者
下次读取
3. 最好是一个人修改，其他人只读取该数据

例子：天气预报系统将天气数据更新，多个对象需要使用到天气的数据。
此时更改者为气象管理员，其他对象共享该数据，该数据只用存取一次，大家共享。

# 共享指针使用方法

## 创建

1. 通过new创建
`std::shared_ptr<int> sp(new int(5));`
2. 通过make_shared<T>创建
`std::shared_ptr<T> sp = std::make_shared<T>(..)`
3. 通过sharepointer创建
m1 `std::shared_ptr<T> sp2 = sp;`
m2 `std::shared_ptr<T> sp2(sp);`

## 特性

1.共享指针很大的一个特点就是引用计数，可以使用use_count()获取，它表明了
该共享指针指向的内容被几个对象使用（这里的使用应当是以共享指针的形式使用）
**当use_count()为0时，再根据该指针访问对象就会出错**

2.转移所有权，当共享指针被转移所有权（如下）时，根据该指针访问所指向的对象也会报错。

## 传递参数

1. 按值传递共享指针
`func(std::share_ptr<T> s);`
**此时共享指针的引用计数会在调用函数时加1，因为参数拷贝**
函数结束运行时，引用计数减1，因为作为临时对象，函数结束时会被摧毁
2. 按地址(指针)传递
`func(std::shared_ptr<T>* S);`
**此时可以通过(*s).get()访问到对象，但是函数内使用时并不会导致引用计数改变**，理论上有些背离初衷

# 注意

需要注意的是，如果调用1.中的函数时使用 func(std::move(sp1)) 会导致sp1的所有权转移到了函数中去，
如果此时引用计数不是1，那么函数结束后，共享指针并不会释放内存，可导致**内存泄漏**，而且sp1也不能访问对象。
